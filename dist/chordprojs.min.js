!(function (e, t) {
  "object" == typeof exports && "undefined" != typeof module
    ? t(exports)
    : "function" == typeof define && define.amd
    ? define(["exports"], t)
    : t(
        ((e =
          "undefined" != typeof globalThis
            ? globalThis
            : e || self).ChordproJS = {}),
      );
})(this, function (e) {
  "use strict";
  function t(e, t = {}) {
    const i = {
      showTitle: !0,
      showSubtitle: !0,
      showChords: !0,
      showComments: !0,
      ...t,
    };
    let n = "";
    return (
      i.showTitle && e.title && (n += `<h1>${s(e.title)}</h1>`),
      i.showSubtitle && e.subtitle && (n += `<h2>${s(e.subtitle)}</h2>`),
      e.artist && (n += `<div class="artist">${s(e.artist)}</div>`),
      e.key && (n += `<div class="key">Key: ${s(e.key)}</div>`),
      e.sections.forEach((e) => {
        "chorus" === e.type
          ? (n += '<div class="section chorus">')
          : (n += '<div class="section verse">'),
          e.lines.forEach((e) => {
            switch (e.type) {
              case "comment":
                i.showComments &&
                  (n += `<div class="comment">${s(e.content)}</div>`);
                break;
              case "chordLine":
                if (i.showChords) {
                  let t = "";
                  e.lyrics;
                  const i = e.chords,
                    o = e.positions;
                  let r = 0;
                  for (let e = 0; e < i.length; e++) {
                    const s = o[e] - r;
                    (t += " ".repeat(Math.max(0, s)) + i[e]),
                      (r = o[e] + i[e].length);
                  }
                  (n += `<pre class="chord-line">${s(t)}</pre>`),
                    (n += `<pre class="lyric-line">${s(e.lyrics)}</pre>`);
                } else n += `<div class="lyric-line-only">${s(e.lyrics)}</div>`;
                break;
              case "lyricLine":
                n += `<div class="lyric-line">${s(e.content)}</div>`;
                break;
              case "empty":
                n += '<div class="empty-line">&nbsp;</div>';
            }
          }),
          (n += "</div>");
      }),
      n
    );
  }
  function s(e) {
    const t = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#039;",
    };
    return e.replace(/[&<>"']/g, (e) => t[e]);
  }
  class i {
    constructor(e = {}) {
      this.options = {
        showTitle: !0,
        showSubtitle: !0,
        showChords: !0,
        showComments: !0,
        ...e,
      };
    }
    parse(e) {
      return (function (e) {
        const t = e.split("\n"),
          s = {
            title: "",
            subtitle: "",
            artist: "",
            key: "",
            sections: [],
            metadata: {},
          };
        let i = { type: "verse", lines: [] };
        return (
          s.sections.push(i),
          t.forEach((e) => {
            if (e.trim().match(/^\{([^:}]+)(?::([^}]+))?\}$/)) {
              const t = e.trim().match(/^\{([^:}]+)(?::([^}]+))?\}$/),
                n = t[1].trim().toLowerCase(),
                o = t[2] ? t[2].trim() : "";
              switch (n) {
                case "title":
                  s.title = o;
                  break;
                case "subtitle":
                case "st":
                  s.subtitle = o;
                  break;
                case "artist":
                  s.artist = o;
                  break;
                case "key":
                  s.key = o;
                  break;
                case "comment":
                case "c":
                  i.lines.push({ type: "comment", content: o });
                  break;
                case "start_of_chorus":
                case "soc":
                  (i = { type: "chorus", lines: [] }), s.sections.push(i);
                  break;
                case "end_of_chorus":
                case "eoc":
                  (i = { type: "verse", lines: [] }), s.sections.push(i);
                  break;
                default:
                  s.metadata[n] = o;
              }
            } else if (e.includes("[") && e.includes("]")) {
              const t = [],
                s = [];
              let n = e;
              const o = /\[([^\]]+)\]/g;
              let r,
                c = 0;
              for (; null !== (r = o.exec(e)); )
                t.push(r[1]),
                  s.push(r.index - c),
                  (c += r[0].length),
                  (n = n.replace(r[0], ""));
              i.lines.push({
                type: "chordLine",
                lyrics: n,
                chords: t,
                positions: s,
              });
            } else
              "" === e.trim()
                ? i.lines.push({ type: "empty" })
                : i.lines.push({ type: "lyricLine", content: e });
          }),
          s
        );
      })(e, this.options);
    }
    renderToElement(e, s) {
      return (function (e, s, i = {}) {
        if (("string" == typeof s && (s = document.querySelector(s)), !s))
          throw new Error("Invalid target element");
        return (s.innerHTML = t(e, i)), s;
      })(this.parse(e), s, this.options);
    }
    renderToHTML(e) {
      return t(this.parse(e), this.options);
    }
    setOptions(e) {
      return (this.options = { ...this.options, ...e }), this;
    }
    isChordPro(e) {
      return /\{.*\}/.test(e) || /\[.*\]/.test(e);
    }
    use(e, t = {}) {
      const s = i.plugins[e];
      if (!s) throw new Error(`Plugin '${e}' not found`);
      return s.install(this, t), this;
    }
  }
  function n(e = {}) {
    return new i(e);
  }
  (i.plugins = {}),
    (i.registerPlugin = function (e, t) {
      i.plugins[e] = t;
    }),
    "undefined" != typeof window && (window.ChordproJS = n),
    (e.ChordproJS = i),
    (e.createChordproJS = n),
    (e.default = n),
    Object.defineProperty(e, "__esModule", { value: !0 });
});
