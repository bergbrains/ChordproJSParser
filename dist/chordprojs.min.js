!(function (e, s) {
  "object" == typeof exports && "undefined" != typeof module
    ? s(exports)
    : "function" == typeof define && define.amd
      ? define(["exports"], s)
      : s(((e = "undefined" != typeof globalThis ? globalThis : e || self).ChordproJS = {}));
})(this, function (e) {
  "use strict";
  function s(e, s = {}) {
    const i = { showTitle: !0, showSubtitle: !0, showChords: !0, showComments: !0, ...s };
    let o = "";
    return (
      i.showTitle && e.title && (o += `<h1>${t(e.title)}</h1>`),
      i.showSubtitle && e.subtitle && (o += `<h2>${t(e.subtitle)}</h2>`),
      e.artist && (o += `<div class="artist">${t(e.artist)}</div>`),
      e.key && (o += `<div class="key">Key: ${t(e.key)}</div>`),
      e.capo && (o += `<div class="capo">Capo: ${t(e.capo)}</div>`),
      e.tempo && (o += `<div class="tempo">Tempo: ${t(e.tempo)}</div>`),
      e.time && (o += `<div class="time">Time: ${t(e.time)}</div>`),
      e.year && (o += `<div class="year">Year: ${t(e.year)}</div>`),
      e.album && (o += `<div class="album">Album: ${t(e.album)}</div>`),
      e.composer && (o += `<div class="composer">Composer: ${t(e.composer)}</div>`),
      e.copyright && (o += `<div class="copyright">Copyright: ${t(e.copyright)}</div>`),
      e.sections.forEach((e) => {
        ("chorus" === e.type
          ? (o += '<div class="section chorus">')
          : "bridge" === e.type
            ? (o += '<div class="section bridge">')
            : (o += '<div class="section verse">'),
          e.lines.forEach((e) => {
            switch (e.type) {
              case "comment":
                i.showComments && (o += `<div class="comment">${t(e.content)}</div>`);
                break;
              case "chordLine":
                if (i.showChords) {
                  let s = "";
                  e.lyrics;
                  const i = e.chords,
                    r = e.positions;
                  let c = 0;
                  for (let e = 0; e < i.length; e++) {
                    const t = r[e] - c;
                    ((s += " ".repeat(Math.max(0, t)) + i[e]), (c = r[e] + i[e].length));
                  }
                  ((o += `<pre class="chord-line">${t(s)}</pre>`),
                    (o += `<pre class="lyric-line">${t(e.lyrics)}</pre>`));
                } else o += `<div class="lyric-line-only">${t(e.lyrics)}</div>`;
                break;
              case "lyricLine":
                o += `<div class="lyric-line">${t(e.content)}</div>`;
                break;
              case "empty":
                o += '<div class="empty-line">&nbsp;</div>';
            }
          }),
          (o += "</div>"));
      }),
      o
    );
  }
  function t(e) {
    const s = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;" };
    return e.replace(/[&<>"']/g, (e) => s[e]);
  }
  class i {
    constructor(e = {}) {
      this.options = { showTitle: !0, showSubtitle: !0, showChords: !0, showComments: !0, ...e };
    }
    parse(e) {
      return (function (e) {
        const s = e.split("\n"),
          t = {
            title: "",
            subtitle: "",
            artist: "",
            key: "",
            capo: "",
            tempo: "",
            time: "",
            year: "",
            album: "",
            composer: "",
            copyright: "",
            sections: [],
            metadata: {}
          };
        let i = { type: "verse", lines: [] };
        return (
          t.sections.push(i),
          s.forEach((e) => {
            if (e.trim().match(/^\{([^:}]+)(?::([^}]+))?\}$/)) {
              const s = e.trim().match(/^\{([^:}]+)(?::([^}]+))?\}$/),
                o = s[1].trim().toLowerCase(),
                r = s[2] ? s[2].trim() : "";
              switch (o) {
                case "title":
                  t.title = r;
                  break;
                case "subtitle":
                case "st":
                  t.subtitle = r;
                  break;
                case "artist":
                  t.artist = r;
                  break;
                case "key":
                  t.key = r;
                  break;
                case "capo":
                  t.capo = r;
                  break;
                case "tempo":
                  t.tempo = r;
                  break;
                case "time":
                  t.time = r;
                  break;
                case "year":
                  t.year = r;
                  break;
                case "album":
                  t.album = r;
                  break;
                case "composer":
                  t.composer = r;
                  break;
                case "copyright":
                  t.copyright = r;
                  break;
                case "comment":
                case "c":
                  i.lines.push({ type: "comment", content: r });
                  break;
                case "start_of_chorus":
                case "soc":
                  ((i = { type: "chorus", lines: [] }), t.sections.push(i));
                  break;
                case "end_of_chorus":
                case "eoc":
                case "start_of_verse":
                case "sov":
                case "end_of_verse":
                case "eov":
                case "end_of_bridge":
                case "eob":
                  ((i = { type: "verse", lines: [] }), t.sections.push(i));
                  break;
                case "start_of_bridge":
                case "sob":
                  ((i = { type: "bridge", lines: [] }), t.sections.push(i));
                  break;
                default:
                  t.metadata[o] = r;
              }
            } else if (e.includes("[") && e.includes("]")) {
              const s = [],
                t = [];
              let o = e;
              const r = /\[([^\]]+)\]/g;
              let c,
                n = 0;
              for (; null !== (c = r.exec(e)); )
                (s.push(c[1]), t.push(c.index - n), (n += c[0].length), (o = o.replace(c[0], "")));
              i.lines.push({ type: "chordLine", lyrics: o, chords: s, positions: t });
            } else
              "" === e.trim()
                ? i.lines.push({ type: "empty" })
                : i.lines.push({ type: "lyricLine", content: e });
          }),
          t
        );
      })(e, this.options);
    }
    renderToElement(e, t) {
      return (function (e, t, i = {}) {
        if (("string" == typeof t && (t = document.querySelector(t)), !t))
          throw new Error("Invalid target element");
        return ((t.innerHTML = s(e, i)), t);
      })(this.parse(e), t, this.options);
    }
    renderToHTML(e) {
      return s(this.parse(e), this.options);
    }
    setOptions(e) {
      return ((this.options = { ...this.options, ...e }), this);
    }
    isChordPro(e) {
      return /\{.*\}/.test(e) || /\[.*\]/.test(e);
    }
    use(e, s = {}) {
      const t = i.plugins[e];
      if (!t) throw new Error(`Plugin '${e}' not found`);
      return (t.install(this, s), this);
    }
  }
  function o(e = {}) {
    return new i(e);
  }
  ((i.plugins = {}),
    (i.registerPlugin = function (e, s) {
      i.plugins[e] = s;
    }),
    "undefined" != typeof window && (window.ChordproJS = o),
    (e.ChordproJS = i),
    (e.createChordproJS = o),
    (e.default = o),
    Object.defineProperty(e, "__esModule", { value: !0 }));
});
